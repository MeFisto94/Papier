using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Threading.Tasks;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace Papier
{
    /// <summary>
    /// This class is responsible for generating syntax tree/string stub classes from CECIL Assembly Metadata.<br />
    /// This is required because we compile individual classes, which have references to other classes of the given
    /// assembly. It is not possible, however, to add the assembly as a reference to the compiler, because that
    /// introduces class duplicates, that cannot be cast into each other (different assemblies).<br />
    /// As a workaround, we compile the changed classes together with a lot of stub classes (stub because that is more
    /// reliable than using a decompiler and have full blown methods, in fact the method bodies are irrelevant anyway).
    /// </summary>
    // TODO: Support for generics.
    public class StubGenerator
    {
        // 4 spaces ident, hard coded :D
        private const string ident = "    ";
        public static async Task CreateStringStub(Stream stringStream, TypeDefinition stubType, HashSet<IMemberDefinition> stubDefinitions)
        {
            await using (var sw = new StreamWriter(stringStream))
            {
                // We use FQN, so we don't need to care about usings

                await sw.WriteLineAsync("// This file has been AUTOGENERATED by Papier. Changes may be LOST.");
                await sw.WriteLineAsync("// If compilation fails because of invalid stubs, open a ticket.");
                await sw.WriteLineAsync(
                    "// As a short-term resolution, you can also fix this file and instruct Papier to _not_ overwrite existing stubs!");
                await sw.WriteLineAsync(
                    "// Note that in the most cases entire stub classes may be missing and won't be picked up by the compiler");

                if (!string.IsNullOrEmpty(stubType.Namespace))
                {
                    await sw.WriteLineAsync($"namespace {stubType.Namespace} {{");
                }

                var modifier = GetModifiers(stubType);

                // Methods that need to be implemented from an interface or that are abstract on a baseclass.
                var requiredMethods = new List<MethodDefinition>();
                var subClasses = "";

                if (stubType.BaseType != null || stubType.HasInterfaces)
                {
                    subClasses = ": ";
                }

                if (stubType.BaseType != null)
                {
                    subClasses += NamespacedType(stubType.BaseType.Namespace, stubType.BaseType.Name);
                    // TODO: Go down type hierarchy and take abstract methods.
                }

                if (stubType.HasInterfaces)
                {
                    foreach (var iface in stubType.Interfaces)
                    {
                        var itype = iface.InterfaceType;
                        subClasses += $", {NamespacedType(itype.Namespace, itype.Name)}";
                        
                        // TODO: Ignore default method impls and validate that.
                        requiredMethods.AddRange(itype.Resolve().Methods.Where(m => !m.IsStatic && !m.HasBody));
                    }
                }

                await sw.WriteLineAsync("[PapierStub]");
                await sw.WriteLineAsync($"{modifier}class {stubType.Name}{subClasses} {{");

                await sw.WriteLineAsync($"{ident}// FIELDS START");
                foreach (var fd in stubDefinitions.Where(x => x is FieldDefinition).Cast<FieldDefinition>())
                {
                    await WriteField(sw, fd);
                }
                await sw.WriteLineAsync($"{ident}// FIELDS END");
                await sw.WriteLineAsync();
                
                await sw.WriteLineAsync($"{ident}// PROPS START");
                foreach (var pd in stubDefinitions.Where(x => x is PropertyDefinition).Cast<PropertyDefinition>())
                {
                    await WriteProp(sw, pd);
                }
                await sw.WriteLineAsync($"{ident}// PROPS END");
                await sw.WriteLineAsync();
                
                await sw.WriteLineAsync($"{ident}// METHODS START");
                foreach (var md in stubDefinitions.Where(x => x is MethodDefinition).Cast<MethodDefinition>())
                {
                    await WriteMethod(sw, md);
                }
                await sw.WriteLineAsync($"{ident}// METHODS END");
                await sw.WriteLineAsync();
                
                await sw.WriteLineAsync($"{ident}// OVERRIDDEN METHODS START");
                foreach (var md in requiredMethods)
                {
                    await WriteMethod(sw, md);
                }
                await sw.WriteLineAsync($"{ident}// OVERRIDDEN METHODS END");
                await sw.WriteLineAsync();
                
                await sw.WriteLineAsync($"}} // class {stubType.Name}");

                if (!string.IsNullOrEmpty(stubType.Namespace))
                {
                    await sw.WriteLineAsync($"}} // namespace {stubType.Namespace}");
                }
            } 
        }

        private static string NamespacedType(string @namespace, string name)
        {
            if ("System".Equals(@namespace) && "Void".Equals(name))
            {
                // Can't use System.Void for some reason.
                // In general a primitive conversion would be nice-to-have, but I don't know about the implications
                return "void";
            }
            
            return string.IsNullOrEmpty(@namespace) ? name : $"{@namespace}.{name}";
        }

        private static async Task WriteField(TextWriter sw, FieldDefinition fd)
        {
            await sw.WriteLineAsync($"{ident}{GetModifiers(fd)}{NamespacedType(fd.FieldType.Namespace, fd.FieldType.Name)} {fd.Name};");
        }
        
        private static async Task WriteProp(TextWriter sw, PropertyDefinition pd)
        {
            // Visibility is non-trivial here: If
            // 1) read- or write-only property -> The property defines the prefix-visibility attribute
            // 2) both properties have the same visibility -> They define the prefix-visibility attribute
            // 3) different visibilities -> The less restrictive is the prefix, the more restrictive in-place.

            var both = pd.GetMethod != null && pd.SetMethod != null;
            var prefix = "";
            var infix_get = false;
            var infix_set = false;

            if (!both)
            {
                prefix = GetModifiers(pd.GetMethod ?? pd.SetMethod);
            }
            else
            {
                var mod1 = GetModifiers(pd.GetMethod);
                var mod2 = GetModifiers(pd.SetMethod);

                if (mod1.Equals(mod2))
                {
                    prefix = mod1;
                }
                else
                {
                    if (pd.GetMethod.IsPublic)
                    {
                        prefix = mod1;
                        infix_set = true;
                    }
                    else
                    {
                        prefix = mod2;
                        infix_get = true;
                    }
                }
            }
            
            await sw.WriteLineAsync($"{ident}{prefix}{NamespacedType(pd.PropertyType.Namespace, pd.PropertyType.Name)} " +
                                    $"{pd.Name} {{ {(infix_get ? GetModifiers(pd.GetMethod) : "")}get; " +
                                    $"{(infix_set ? GetModifiers(pd.SetMethod) : "")}set;}}");
        }
        
        private static async Task WriteMethod(TextWriter sw, MethodDefinition md)
        {
            var parms = "";
            if (md.HasParameters)
            {
                foreach (var pd in md.Parameters)
                {
                    parms += $"{GetModifiers(pd)}{NamespacedType(pd.ParameterType.Namespace, pd.ParameterType.Name)} {pd.Name}, ";
                }

                // This condition is in theory redundant...
                if (!string.IsNullOrEmpty(parms))
                {
                    parms = parms[..^2]; // remove trailing ", "
                }
            }

            if (md.IsConstructor)
            {
                // Constructors, as opposed to any other method, may _need_ to call the specific base-class constructor.
                // This is really not the domain of the stub generator....
                var @base = "";
                var bt = md.DeclaringType.BaseType?.Resolve();
                if (bt != null)
                {
                    // Idea: find the first call instruction that is a constructor of the basetype (well there can only be one)
                    // Not sure if we could stop after the first call in general, but who cares.
                    var constructor = md.Body.Instructions.Where(i =>
                            i.OpCode == OpCodes.Call || i.OpCode == OpCodes.Callvirt || i.OpCode == OpCodes.Calli)
                        .Select(i => i.Operand).Cast<MethodDefinition>()
                        .FirstOrDefault(cmd => cmd.IsConstructor && cmd.DeclaringType.Equals(bt));

                    if (constructor != null)
                    {
                        // Problem now: find a valid combination of md parameter-names, that correspond to constructor's
                        // parameter types. This can't be done perfectly (e.g. when a type occurs multiple times, or 
                        // when constructor requires a type not present in param), but it's only about stubbing here
                        // anyway. An alternative solution would inspect the opcode around the method call to find the
                        // arguments, but at that point we're writing a half decompiler.
                        @base = ": base(";

                        if (constructor.HasParameters)
                        {
                            var superParamList = md.Parameters.ToHashSet();
                            foreach (var cp in constructor.Parameters)
                            {
                                var cpt = cp.ParameterType.Resolve();
                                var sp = superParamList.FirstOrDefault(p => 
                                    IsAssignableFrom(cpt, p.ParameterType.Resolve()));

                                if (sp == null)
                                {
                                    await Console.Error.WriteLineAsync($"Could not find a matching parameter in {md} to pass to {constructor} for {cp}, passing null");
                                    @base += "null, ";
                                }
                                else
                                {
                                    superParamList.Remove(sp);
                                    @base += $"{sp.Name}, ";
                                }
                            }
                        }

                        @base = @base[..^2]; // remove trailing ", "
                        @base += ")";
                    }
                }
                
                await sw.WriteLineAsync(
                    $"{ident}{GetModifiers(md)}{md.DeclaringType.Name}({parms}){@base} {{ }}");
            }
            else
            {
                var returnStatement = GetReturnStatement(md.ReturnType);
                await sw.WriteLineAsync(
                    $"{ident}{GetModifiers(md)}{NamespacedType(md.ReturnType.Namespace, md.ReturnType.Name)} {md.Name}({parms}) {{ {returnStatement}}}");
            }
        }

        private static string GetReturnStatement(TypeReference type)
        {
            var def = GetDefaultReturnValueForType(type);

            if (def == null)
            {
                return "";
            }
            else
            {
                return $"return {def}; "; // Trailing whitespace intentional
            }
        }

        private static string? GetDefaultReturnValueForType(TypeReference type)
        {
            if (!type.Namespace.Equals("System"))
            {
                return "null";
            }
            else
            {
                return type.Name switch
                {
                    "Void" => null,
                    "Boolean" => "false",
                    "Int32" => "0",
                    "UInt32" => "0",
                    "String" => "",
                    _ => "null"
                };
            }
        }

        // TODO: More modifiers?
        private static string GetModifiers(FieldDefinition fd)
        {
            var modifiers = "";
            if (fd.IsPublic)
            {
                modifiers += "public ";
            }

            if (fd.IsPrivate)
            {
                modifiers += "private ";
            }

            if (fd.IsStatic)
            {
                modifiers += "static ";
            }

            return modifiers;
        }
        
        private static string GetModifiers(MethodDefinition md)
        {
            var modifiers = "";
            if (md.IsPublic)
            {
                modifiers += "public ";
            }

            if (md.IsPrivate)
            {
                modifiers += "private ";
            }

            if (md.IsStatic)
            {
                modifiers += "static ";
            }

            return modifiers;
        }
        
        private static string GetModifiers(TypeDefinition md)
        {
            var modifiers = "";
            if (md.IsPublic)
            {
                modifiers += "public ";
            }

            if (md.IsSealed)
            {
                modifiers += "sealed ";
            }
            
            return modifiers;
        }

        private static string GetModifiers(ParameterDefinition pd)
        {
            var modifiers = "";
            if (pd.IsIn)
            {
                modifiers += "in ";
            }

            if (pd.IsOut)
            {
                modifiers += "out ";
            }
            
            // TODO: Ref? What is Lcid

            return modifiers;
        }

        /// <summary>
        /// Determines if packedType can be assigned to a baseType, which means that baseType is an interface 
        /// implemented by packedType or a class that is extended.
        /// </summary>
        /// <param name="packedType"></param>
        /// <param name="baseType"></param>
        /// <returns></returns>
        public static bool IsAssignableFrom(TypeDefinition baseType, TypeDefinition packedType)
        {
            var curr = packedType;
            while (curr != null)
            {
                if (curr.Equals(baseType))
                {
                    return true;
                }

                if (baseType.IsInterface && curr.HasInterfaces)
                {
                    if (curr.Interfaces.Any(x => baseType.Equals(x.InterfaceType?.Resolve())))
                    {
                        return true;
                    }
                }
                
                curr = curr.BaseType?.Resolve();
            }

            return false;
        }
        
        public static void WriteStubAttribute(TextWriter sw) {
            sw.WriteLine("// This Attribute is auto-generated by Papier");
            sw.WriteLine("// Every stub method is annotated with it, so that when merging the IL, those stub classes get dropped");
            sw.WriteLine("[System.AttributeUsage(System.AttributeTargets.Class)]");
            sw.WriteLine("public class PapierStubAttribute : System.Attribute {");
            sw.WriteLine("    public PapierStubAttribute() {}");
            sw.WriteLine("}");
        }
    }
}